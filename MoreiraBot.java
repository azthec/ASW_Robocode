
//http://robowiki.net/wiki/Module/Movement/AntiGravity
//http://robowiki.net/wiki/HawkOnFire
//https://www.ibm.com/developerworks/library/j-antigrav/

import robocode.*;
import robocode.AdvancedRobot;
import robocode.util.Utils;

import GravPoint;
import GravEngine;

import java.awt.geom.Point2D;
import java.util.Hashtable;



/**
 * fun TODO
 * add detection for rihanna and other wallwalkers 1v1 and use linear targeting
 * add 1v1 detection to generate perpendicular attractive points to enemy
 * 
 * @author azthec
 *
 */

public class MoreiraBot extends AdvancedRobot {

	GravEngine gravEngine;
	int randomGen = 0;
	double randomStrength = 0;
	double randomX = 0;
	double randomY = 0;

	static microEnemy target;
	static Hashtable enemies = new Hashtable();
	static Point2D.Double myPos;

	public void run() {
		setAdjustGunForRobotTurn(true);
		setAdjustRadarForGunTurn(true);
		//Spinning Radar until 1v1
		setTurnRadarRightRadians(Double.POSITIVE_INFINITY);

		//Initialize GravPoint map
		gravEngine = new GravEngine(getBattleFieldWidth(), getBattleFieldHeight());

		target = new microEnemy();

		do {
			//update my position every cycle
			myPos = new Point2D.Double(getX(),getY());

			//Add randomness to movement, otherwise gets stuck jiggling on local maximum, hard to manage strength sometimes bot gets pushed to walls
			randomGen++;
			if(randomGen > 5) {
				randomGen = 0;
				randomStrength = (Math.random() * 125) - 50;
				randomX = Math.abs((Math.random() * (getBattleFieldWidth()*0.75)) - (getBattleFieldWidth()*0.25)); //if not absolute can return negative values and run bot into walls
				randomY = Math.abs((Math.random() * (getBattleFieldHeight()*0.75)) - (getBattleFieldHeight()*0.25));
				gravEngine.addPoint(new GravPoint(randomX, randomY, randomStrength, getTime(), 5));
			}

			if(target.live && getTime()>9) { //does nothing until it has acquired all bots in play
				doMovementAndGun();
			}

			execute();

		} while(true);
	}

	public void doMovementAndGun() {

		//*********movement**********//
		gravEngine.update(getX(), getY(), getTime()); //removes dead gravpoints and calculates direction based on existing GravPoints and Walls
		double xForce = gravEngine.getXForce(); // * (Math.random() *5);
		double yForce = gravEngine.getYForce(); // * (Math.random() *5);
		double angle = Math.atan2(xForce, yForce);

		//turn to face position and go to
		if (xForce == 0 && yForce == 0) {
			// If no force, do nothing, never actually happens
		} else if(Math.abs(angle-getHeadingRadians())<Math.PI/2){
			setTurnRightRadians(Utils.normalRelativeAngle(angle-getHeadingRadians()));
			setAhead(Double.POSITIVE_INFINITY);
		} else {
			setTurnRightRadians(Utils.normalRelativeAngle(angle+Math.PI-getHeadingRadians()));
			setAhead(Double.NEGATIVE_INFINITY);
		}

		//*************gun************//
		/**Damage heuristic:
		 * If damage under 1 never fire
		 * If low on energy drop bullet strength accordingly
		 * If enemy is farther away reduce damage (large shots move slower but hit more often at close range)
		 * If enemy is low on energy fire with reduced damage (so as not to waste energy on overkill)
		 */
		double distanceToTarget = myPos.distance(target.pos);
		if(getGunTurnRemaining() == 0 && getEnergy() > 1) {
			setFire(Math.min(Math.min(getEnergy()/6d, 1300d/distanceToTarget), target.energy/3d));
		}
		setTurnGunRightRadians(Utils.normalRelativeAngle(calcAngle(target.pos, myPos) - getGunHeadingRadians()));
	}


	/**
	 * Event triggered every time the scan detects a robot
	 * there is no 'radar-shadow' generated by another bot, 
	 * so all scans are perfect and can never miss a robot
	 */
	public void onScannedRobot(ScannedRobotEvent e) {

		//******************Add repulsion point at enemy location******************//
		double absBearing = e.getBearingRadians() + getHeadingRadians();
		// Calculate the coordinates of the enemy robot
		double enemyX = getX()+e.getDistance()*Math.sin(absBearing);
		double enemyY = getY()+e.getDistance()*Math.cos(absBearing);
		gravEngine.addPoint(new GravPoint(enemyX, enemyY, -1, getTime(), 5));

		//******************Update enemy and target heuristic******************//
		microEnemy en = (microEnemy)enemies.get(e.getName());
		if(en == null){
			en = new microEnemy();
			enemies.put(e.getName(), en);
		}

		en.energy = e.getEnergy();
		en.live = true;
		en.pos = new Point2D.Double(enemyX, enemyY);
		//Targeting heuristic: attack closest alive enemy
		if(!target.live || e.getDistance() < myPos.distance(target.pos)) {
			target = en;
		}

		//******************Infinity lock on 1v1******************//
		if(getOthers()==1)	setTurnRadarLeftRadians(getRadarTurnRemainingRadians());


	}

	public void onRobotDeath(RobotDeathEvent e) {
		((microEnemy)enemies.get(e.getName())).live = false;
	}
	
	private static double calcAngle(Point2D.Double p2,Point2D.Double p1){
		return Math.atan2(p2.x - p1.x, p2.y - p1.y);
	}

	public class microEnemy {
		public Point2D.Double pos;
		public double energy;
		public boolean live;
	}






	
	
	
	
	
	
	
	
	
	


	/////**********Targeting with events (no enemy preference heuristic)***************/////////
	//Example of Noniterative Linear Targeting @ wiki
	public void linTargeting(ScannedRobotEvent e) {
		double absoluteBearing = getHeadingRadians() + e.getBearingRadians();
		setTurnGunRightRadians(Utils.normalRelativeAngle(absoluteBearing - 
				getGunHeadingRadians() + (e.getVelocity() * Math.sin(e.getHeadingRadians() - 
						absoluteBearing) / 13.0)));
		setFire(e.getEnergy() / 4);
	}

	/*
	 * http://robowiki.net/wiki/Melee_Strategy/UnderstandingInfinity
	 */
	public void modLinTargeting(ScannedRobotEvent e) {
		double absBearing = e.getBearingRadians() + getHeadingRadians();
		setTurnGunRightRadians(robocode.util.Utils.normalRelativeAngle(absBearing - getGunHeadingRadians() + 
				Math.max((1 - e.getDistance() / (500+100)),0) * 											//GUN_FACTOR = 500
				Math.asin(e.getVelocity() / 11) * Math.sin(e.getHeadingRadians() - absBearing) ));	
		setFire(e.getEnergy() / 4);
	}

	//headontargeting for event e
	public void hawkHeadOnTargeting(ScannedRobotEvent e) {
		double distanceToTarget = e.getDistance();

		//**** gun ******************//
		if(getGunTurnRemaining() == 0 && getEnergy() > 1) {
			setFire( Math.min(Math.min(getEnergy()/6d, 1300d/distanceToTarget), e.getEnergy()/3d) );
		}
		double absoluteBearing = getHeadingRadians() + e.getBearingRadians();
		setTurnGunRightRadians(Utils.normalRelativeAngle(absoluteBearing - getGunHeadingRadians()));
	}

}


